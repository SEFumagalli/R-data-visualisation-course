---
title: "R Notebook"
author: "Hannah Meyer"
date: "01/08/2020"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

# Setting up
The document you are looking at right now is a R Notebook. R Notebooks allow
us to interleaf text describing our analysis with the R code that
actually contains the analyses commands. 

The text follows some simple markdown rules (for instance bold header sections
etc, which we won't go into detail here). Important for us at this stage is
that whenever we want to include analysis code into the document, we have
to create an R code *chunk*. To include a new *chunk* click the _Insert_ buttom
at the top of your editor window and select _R_.

All code *chunks* have some default settings, concering their layout, execution
etc, which can be heavily customised. For our beginners tutorial, we do not
have to worry about all of these. I mention this here, as the following and
first chunk of our document contains some basic options that I want to have
applied to all chunks in the rest of the document. Specifically, it tells R
studio that when I prepare this document for sharing with you as a pdf, that
I want both the actual code and the results displayed in the document.


```{r setup}
knitr::opts_chunk$set(echo = TRUE,
                      comment = "#>",
                      collapse = TRUE,
                      fig.width = 6, fig.asp = 0.618, fig.align = "center",
                      out.width = "70%")
```

I then follow with a chunk that loads all libraries required for my analysis.
The following chunk loads the libraries that you installed as a preparation for
the course into our R workspace:

```{r libraries, message=FALSE}
library("tidyverse")
library("cowplot")
library("sf")
library("rnaturalearth")
library("RColorBrewer")
```

**Note**: Libraries only have to be installed once, however, they will have to
be loaded into the R workspae whenever we open a new R session. Think of the
libraries you install as tools that you buy: you buy a hammer the first time you
realise you
want to hang a picture and need a hook in the wall. Once you bought it, you need
to actually bring it to the room where you want to hang the picture. After that,
you have the hammer and can use it whenever you like. The hammer is you the
library that you install (buy) once and then load into your R workspace (use)
whenever you have a task that can be accomplished with that hammer.

# Reading your data
To analyse the data, we will first need to read it into the R workspace.
We can do this with the `read_csv` function as below. Whenever we use a function,
there are two possible outcomes that we might want to see:

1. we simply want to see the result of the function displayed after execution;
2. we want to store the result in a variable for future use. 

To assign the outcome of a function into a variable, we use the assign operator
`<-`. To simply see the results without later access to it, we just type the
command and execute it.

Whenever I set up a new analyses, I usually specify the directory where all the
data are stored and to which we will write the results at the beginning
of my analysis and save it in a object. I use this object in conjuction with
the function `file.path` to specify where I am reading data from and where I
will write data to. Using this strategy, I always know where the data that
belongs to the analysis is stored and if ever I change my folder structure
changes, I only need to change the directory specification once,
(when declaring the variable) and not many times throughout the code. 

To put this all together, in the following chunk, we first assign the path
to our data directory into the object `datadir`, a name of my own chosing and
create a object that stores the name of our input datafile. We then pass the
new `file_coordinates` object to the `read_csv` function and assign
the ouput to a new object called `coord`.

```{r paths, message=FALSE}
datadir <- "~/Teaching"
file_coordinates <- file.path(datadir, "2004_Science_Smith_data.csv")

coord <- read_csv(file_coordinates)
```
`read_csv()` prints out a column specification that gives the name and type of
each column.

## Exercises
1. Have a look at the `file_coordinates` object by creating a new chunk,
typing `file_coordinates` and executing the code chunk. What did the `file.path`
   function do?
2. In the same chunk, have a look at what the the `coord` object looks.


# Data and object types
## Data types
The most common data types in R are:
    
* `int` stands for integers i.e 1, 2, 3.
* `dbl` stands for doubles, or real numbers i.e. 1.2, 1.7, 9.0
* `chr` stands for character vectors, or strings i.e. "a", "b", "word"
* `lgl` stands for logical, vectors that contain only TRUE or FALSE.
* `fctr` stands for factors, which R uses to represent categorical variables
with fixed possible values.

## Object types
There are many different data types in R. For the purpose of data visualisation
and this workshop, we will only work with two object types:

* `data.frame`: a list of variables with the same number of observations.
Variables are in columns, observations in rows. Rows have unique rownames.
* `tibble`:  tibbles are opinionated data frames with an improved printing
  display, stricter rules for re-formating that aid in avoiding bugs and no
  rownames.

**Note**: Tibbles are newer than data.frames and some old functions will not
work with them and might require actual data.frames; For the majority of our
analyses and visualisations we will work with tibbles.


## Exercises: 
1. Which data types are present in our dataset?
2. How many observations and variables are in our dataset?
3. What are the variables?

# A recipe for generating graphs with ggplot2

1. Setting up a coordinate system with the function `ggplot()`: provide the
  dataset to use in the graph
1. Adding layers to `ggplot()`: `geom_xxx()` functions add graphical layers to
  your plot:
  * layers are quite literally added to `ggplot()` object, by using the `+` 
    operator
  * each geom function expects a mapping argument which defines how variables
    are mapped to visualisation. The mapping argument is provided with `aes()`,
    where the x and y arguments describe which variables to map to the x and y
    axes. ggplot2 looks for the mapped variables in the data argument to
    `ggplot()`.
  * There are many geom functions that each add a different type of
    layer to a plot. Their names are very descriptive, for instance:
      * `geom_point` adds a layer of points to the coordinate system,
        effectively creating a scatterplot
      * `geom_histogram` adds a histogram layer
      * `geom_boxplot` adds a boxplot layer

## Our first plot

```{r first plot}
p <- ggplot(data=coord)
p + geom_point(mapping=aes(x=x.coordinate, y=y.coordinate))
```

### Exercises
1. Run ggplot(data = coord). What do you see?
2. What makes this simple plot look very different from the map that we want 
  to achieve?
3. What other information in our data object `coord` could we use?

## Mapping additional aesthetics
To map additional information onto our 2d scatter plot, ggplot2 makes use of
aesthetics. We have already seen aesthetics in the example above, where we
mapped the `x.coordinate` and `y.coordinate` to the x- and y-axis using
`aes(x=x.coordinate, y=y.coordinate)`. Broadly speaking, aesthetics are the
visual properties of the objects in your plot. They include for instance the
size, shape, or color of your points. The different flavors of an aesthetic
are called levels. The levels in the shape aesthetic are for instance round, 
triangular and square. Levels of the color aesthetic could be blue, red and 
yellow. In our graph above, we have not used any of these aesthetics yet.
Let's start by introducing color to the plot. As in the original publication,
we can color the points in our plot by cluster name. We do this by simpling 
specifying the color aestetic in the mapping:

```{r color aes}
p + geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster))
```

 `ggplot2` automatically assign a unique color level to each unique value of
cluster. This assigment process is called scaling. Depending on data and
aesthetic, `ggplot2` selects a reasonable scale and constructs a legend that
explains the mapping between levels and variable values, in this case color
and cluster. However, we can also provide our own color-scheme.

## Setting scales
Adding scales to `ggplot` objects follows the same scheme as adding layers: we
add the scale to the existing object by the `+` operator. Similar to `geom_xxx`,
we have `scale_xxx_yyy`: xxx specifies the aestetic for which we are providing
the scale, yyy specifies the type of scale we want. For instance:
  
  * `scale_color_continuous` sets a continuous scale for the asthetic color;
  * `scale_shape_discrete` sets a discrete scale for the asthetic shape.

When selecting a color-scale (or any scale really), we need to consider what
type of data we are displaying and what message we want to convey:
  
  * qualitative data: unordered, distinct categories, as in our example cluster
    names;
  * sequential data: ordered data that progresses from low to high, as in our
    example 'year of isolation';
  * diverging data: data from low to high, with emphasis on mid-range values as
    well for instance correlations that range from -1 to 1, where the mid-range
    around 0 ie no correlation are equally important to be visualised

The [colorbrewer website](http://colorbrewer2.org/) provides a great resource
to pick appropriate color scales.

`ggplot2` has direct access to these color schemes:
```{r brewer, fig.asp = 2.5, echo = FALSE}
par(mar = c(0, 3, 0, 0))
RColorBrewer::display.brewer.all()
```


```{r color scale}
p +
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster)) +
  scale_color_brewer(type="qual", palette = "Set3")
```
To set an aesthetic manually, you move it outside the mapping argument and 
specify the level:

```{r manual aesthetic}
p +
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster), shape=17) +
  scale_color_brewer(type="qual", palette = "Set3") 
```

### Exercises
1. Try changing the cluster aesthetic to `size` and `shape`. Does this convey
the same level of information as a color scale?
2. What other variable in our dataset would be well represented by a `shape`
scale? Add a shape aesthetic for the variable you identified.
3. Generally speaking, which type of data lends itself to shape scales, which
to size, which to color?
4. Why does this not work?
```{r}
p +
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster)) +
  scale_color_brewer(type="qual", palette = "Set1")
```

5. Why does this code not color all points in red?
```{r}
p +
  geom_point(aes(x=x.coordinate, y=y.coordinate, color="red")) 
```

## Setting labels and themes
So far, we have been concerned with the data layers of the plot, using
`geom_xxx` to visualise different variables and `scale_xxx_yyy` to customise
them. In the following section, we will have a look at customising the 'canvas'
of the plot, i.e. the background, axis labels etc.

### Coordinate system
Looking at the antigenic map (Figure 1 in the Smith *et al* (2004) paper), we
notice that their axis ratio of 1:1, ensuring that one unit on the y-axis is 
equivalent to one unit on the y-axis. Our plot has a different ratio. Based on
the range of the `x.coordinate` and `y.corrdinate` variable, `ggplot` 
automatically chose the axis limits and more importantly here, their ratios. 
We can easily change this default by adding a `coord_xx` layer, in this case
`coord_fixed`, which will ensure a 1:1 ratio per default.

```{r coordinate system}
p + 
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster)) +
  scale_color_brewer(type="qual", palette = "Set3") +
  coord_fixed()
```

### Labels
Currently, the axis and legend labels in our plot are simply the name of
the variables we mapped to the aesthetics. We can change the axis labels by
providing arguments to the `labs` layer. Specifically, x and y axis
labels can be set by the `xlab` and `ylab` arguments respectively, the title
is specified by the `title` argument. To change the name of a legend, we have
to specify the aesthetic we mapped it to, in this `color`.

```{r labels}
p + 
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster)) +
  scale_color_brewer(type="qual", palette = "Set3") +
  labs(x="Dimension 1 [AU]",
       y="Dimension 2 [AU]",
       title="Antigenic cartography",
       color="Cluster") +
  coord_fixed()
```

### Themes
Finally, we can customise the non-data components of our plot. While the
developers of `ggplot2` had a strong preference for the default grey background,
this is not to everyone's liking. As with everything else you've seen so far,
there are some build-in options for customising. Here, we use the `theme_bw`
to change to a white background.

```{r themes}
p + 
  geom_point(aes(x=x.coordinate, y=y.coordinate, color=cluster)) +
  scale_color_brewer(type="qual", palette = "Set3") +
  labs(x="Dimension 1 [AU]",
       y="Dimension 2 [AU]",
       title="Antigenic cartography",
       color="Cluster") +
  coord_fixed() +
  theme_bw()
```

### Exercises
1. What other coordinate system options exist? Hint: type `?coord_` in a new
chunk and press tab to see other options.
2. Rename the legend title for the `shape` aesthetic
3. Test different themes and see how it effects the plot, for instance use
`theme_void`, `theme_dark` and `theme_classic`. Similar to Exercise 1, you can 
type `?theme_` and tab to see other possible build in themes.

```{r echo = FALSE, fig.cap = "The eight themes built-in to ggplot2."}
#knitr::include_graphics("images/visualization-themes.png")
```
## Saving your plots
You can save your plots with the `ggsave` function. `ggsave` will save the most
recent plot to your project directory. As argument we only have to provide the
name of the file we want to save it to. `ggsave` will determine the format
of the output file based on the file ending of the filename that you provide.
For instance, the code chunk below will save our most recent plot to a pdf
document named "antigenic_cartography.pdf". 

```{r save plots}
ggsave(filename="antigenic_cartography.pdf")
```

Not only does `ggsave` determine the format of the file from the name, it also
determines the size of the file from the size we chose for displaying the plot
in out analysis. To make it reproducible, it is good practice to specify the
size and units. 

```{r save plots parameters}
ggsave(filename="antigenic_cartography.pdf", width=5, height=8, unit="cm")
```
**Note**: `ggsave` overwrites the previous file of that name without warning!

### Exercises
1. Save the plot as png and jpeg.
2. Change the size of the plot with width and height; what happens to figure
labels and legends?

